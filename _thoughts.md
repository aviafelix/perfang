# Thoughts, ideas

1. Зачем запускать процесс через cmd и затем убивать его, если можно (наверное?) запустить через start... (Windows)? Как запустить в Linux? Решение не будет работать в Linux! Нужно ли?
2. "Хеш" для изображения исправить.
3. Сделать общий объект "Browser", чтобы затем можно было отдельно запускать Chrome и Firefox (и всё, что угодно).
4. Продумать более подходящий и надёжный процесс определения окончания загрузки страницы.
5. Поискать другие варианты сохранения HAR-файлов. Мне казалось, что их возможно сохранять и так (PhantomJS?).
6. Сохранять pid запущенного процесса Chrome и останавливать этот процесс и все его подпроцессы (наверное, так не будут закрыты ранее открытые окна):
  * https://psutil.readthedocs.io/en/latest/#filtering-and-sorting-processes
7. Файлы сохраняются в .jpg, а не в .png!
8. Не происходит фокусировки на окно браузера при его запуске. Может быть запускать окно и производить некоторые операции через WinAPI?
9. Добавить логирование сообщений с одновременным выводом в консоль.
10. В начале работы создавать рабочий экземпляр базы данных при необходимости (минимально заполнять нужным образом).
11. Множество ошибок в работе инструмента (например, сообщать конкретную причину ошибки в работе приложения, если она случается; при удалении страницы в любом случае сообщается "Страница удалена" и т. д.).
12. Результаты сохранять в папки вида YYYY_MM_dd (с ведущими нулями при необходимости), а не как-то иначе.
13. Результаты тестов очень объёмные. Подумать над выборочным хранением, либо над централизованным хранением, либо...
14. Добавление страниц неудобно (сделать какой-то интерфейс, какой-нибудь подходящий API, что-то вроде добавления из командной строки либо же через скрипт:
  > python sender.py [command:add/replace/change/modify/delete/test/...] [-keys] page_name page_url ...
15. Расширение .db для баз данных.
16. Время в базе данных должно храниться в более удобном виде.
17. Что, если получится измерять скорость загрузки через анализ событий, связанных с перерисовкой Layout?
    Они описаны ниже (Rendering event properties и ниже):
    https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference
    https://gist.github.com/paulirish/5d52fb081b3570c81e3a
18. Добавить флаги для запуска Хрома, отключающие страницу первого запуска, переводы и проч.
19. Порты указывать вместе с сервером, так как на одной машине может быть запущено несколько процессов серверов; в коде Перфалайза порт местами указан явно (исправить).
20. Зачем-то требуется указывать слейву имя страницы и её адрес. Достаточно задавать что-то одно. Или как-то иначе.
21. В строке test.py:234 `test = PerfTestUnit(url, label)` объект `test` может быть не создан (с исключением).
В результате вызова метода несуществующего объекта `test.close_tab()` возникнет необработанное исключение.
22. Command-line interface.
23. Distributed nodes.
24. Добавление заданий в очередь для выполнения.
25. Использовать ли simple_json в haralyze, есть ли необходимость в ускорении?
26. Консольный фронт-энд для мастер-сервера. Он может как отправлять задачи (через мастер-ноду), так и получать данные с мастера.
27. Очереди и асинхронное выполнение задач.
28. API мастер/солнца серверов для обмена метриками (получением/запросом/отправкой).
29. И точки соединения их и объектов.
30. А консольный клиент мог бы подключаться не только к слейвам, но и к мастеру.
31. Зная одну из нод, он мог бы узнать об остальных, сохранять эту информацию.
32. Ввести default config, из которого будут браться значения по умолчанию. Они будут должны переписываться значениями
  из пользовательского конфига. Ну, и приоритеты по конфигурированию переменными среды и аргументами командной строки
33. ThreadPoll... + Queue
34. Стандартные "метрики" из встроенных модулей + направлять `_routines` с внутренними именами; правила обработки будут задаваться где-то в общем месте. Обязательно добавлять token в запросах для сверки (токен местера и токены слейвов).
35. Защита от повторного запуска.
36. Добработка скриншотов: более удобное именование файлов для просмотра как в подпапках, так и сами их имена;
    возможность копировать файлы в одну папку для быстрого просмотра (имя файла: номер замера; время; ...)
37. {"jsonrpc":"2.0","protocol":5,"method":"...","params":{...},"id":1}
38. Уменьшить количество отдельных файлов для запуска сервера с командами вроде:
    ```bash
        $ master start / stop
        $ # или:
        $ server [master|slave] start / stop
        $ # или:
        $ server start / stop [master|slave|all]
        $ # или:
        $ [re]start[-server] [master|slave|all]
        $ stop[-server] [master|slave|all]
    ```
39. О том, как общаются между собой ноды. Предполагаю такой сценарий: мастер должен быть запущен первым. Затем запускаются слейв-ноды, которые знают только свой конфиг по умолчанию (свои хост+порт и адрес мастера; возможно — особенности хоста [пример: медленна/быстрая машина], на котором она запущена — либо об этом должен знать сам мастер). Общаясь с мастером, они обмениваются по определённому протоколу информацией. Определённая конфигурация (сервера для аутентификации, сбора версий и проч.) забирается каждой слейв-нодой с мастера. Либо часть нужной информации отправляется мастером в момент передачи им заданий слейвам. Мастер хранит у себя текущий список нод, а также передаёт каждой из них случайные токены (сессии), по которым узнаёт, которая из нод с ним общается (тогда будет проблематично перепутать эти ноды).
40. Данные (метрики), которые передают слейвы, вообще говоря могут не совпадать по типам с теми, которые хранит у себя мастер: есть какие-то предобработчики и сплиттеры, которые могут отправлять данные по разным направлениям (база+заббикс, допустим)
41. Для метрик выводить типы на основе присланных данных или же они предопределяются источниками? Вероятно, пока можно будет использовать методы SQLAlchemy; но у нас же есть ещё файлы (как данные измерений — тоже своего рода метрика); каталоги с файлами; метрики, которые нужно перенаправить куда-то (возможно, с сохранением в несколько источников); Zabbix, Graphite\Graphana etc.
42. Для заданной страницы запрашиваем сбор метрик (или имя группы метрик) со слейва. Слейв, если не знает что-то, может попроовать узнать у мастера. Либо мастер отправляет сразу всю возможную информацию: имена метрик, логика их сбора (в py-файлах, возможно).
43. Предназначения утилиты:
  * удобным образом получать задания,
  * следить за статусом выполняемых задач,
  * получать данные о проведённых испытаниях со слейва,
  * получать файлы (например, har) для определённых страниц локально из хранилища или со слейвов,
  * строить простейшие статические графики.
44. Работа из Jupyter Notebook \ Sublime Text (как Hermes).
45. (NB Вывод JS (графика, текст...) возможен не только в браузерах, но и в редакторах, основанных на браузерных движках.)
46. Описание протокола Jupyter Notebook: https://speakerdeck.com/rgbkrk/jupyter-frontends-from-the-classic-jupyter-notebook-to-jupyterlab-nteract-and-beyond
47. Execution Statuses: busy\idle\...
48. В конфигах, конечно, должны присутствовать опции, с которыми запускается браузер.


# Fixes, errors

 * Иногда не фокусируется браузер
 * Падает замер, если указаны недействительные для данного стенда логин/пароль
 * Возникают ошибки при записи в БД (см. логи)
 * Расширение для базы данных: .db (или .sqlite) [имя задавать в конфиге]
 * logs.py:261 :: не должна ли там быть таймзона? или не использовать ли вместо «хака» utcfromtimestamp?
   https://bugs.python.org/issue29097
 * тип таймстампов/временная зона должны быть согласованы на машинах.
 * test.py:208 Код можно сильно упростить. Не нужно использовать enumerate. Ну, и logs[bool] сделать как-то понятнее.
 * Иногда база оказывается задача и не разблокируется.
 * Следует округлять значения времён загрузки страниц до 100 или до 50 мс
 * Актуальное и информативное описание в логах.
 * Посмотреть ещё раз: а что оно так долго меряется?
 * Ссылки на файлы должны быть относительными.
 * Отделить логику от веб-сервера
 * Возможно, что было бы удобно помечать папки с har-файлами по признаку "cache disabled?"
 * Разобраться, почему происходит ошибка записи в БД
 * подобрать список страниц для анализа
 * найти ту часть, которая будет отвечать за выполнение запросов к слейву
 * выбрать способ запуска тестов через определённый промежуток времени (или в определённое время)
 * разобраться со сравнением har-файлов
 * Насчёт каталога .idea: можно хранить сам каталог, но исключать некоторые файлы по маске: https://stackoverflow.com/questions/11968531/what-to-gitignore-from-the-idea-folder
 * async?
 * папка в корне перегружена стартовыми скриптами. Перенести их в служебную папку.
   Для кроссплатформенности эти скрипты могут быть на Питоне. Или просто различные варианты
   (shell/bash; cmd; py)
 * Какая-то ерунда с временными метками при снятии скриншотов долго открывающейся страницы (те скриншоты, которые должны попасть в конец,
   оказываются по времени в самом начале, в том числе с отрицательным временем.
 * Поискать свои скрипты сравнения har-файлов.
 * Информацию о выполнении сбрасывать в логи, а также можно в Телеграм, м?
 * Управление не только из браузера и консоли, но и через телеграм-бота?

 * :
    - выполнить перед началом сбора метрик;
    - выполнить по окончанию сбора метрик;
    - различать одновременный сбор метрик и последовательный.

 * Сохранять pid процессов.
 * Похоже, что конфиги для мастера и слейвов это должны быть отдельные файлы.
 * :
    /config
    /ver
    на всех нодах.

 * Как сохранять состояние нод, чтобы не терялись задания, что делать при падении нод?
 * magick-pendel
 * Мастер и слейв могут общаться между собой; консольный клиент может общаться только с мастером (делать запросы).
     (?perfang)/api/master/v0.1/...
     (?perfang)/api/slave/v0.1/...
     А то вдруг кто-то захочет обратиться на году по похожему api...

 * А сообщения между общающимися, по-хорошему говоря, нужно подписывать.
 * Слейвы должны слушаться мастера беспрекословно. В то же время мастер должен с пониманием относиться к работе слейвы и не мешать им зря.
 * Запуск слейвом работы по команде мастера (run).
 * /api/v1/blablabla
 * На слейв отправляем правила для сбора класса, экземпляр которого при вызове определённых методов выполняет сбор метрик. Операция с определённым идентификатором.
На мастере из полученных данных с помощью некоторой логики обрабатываем их и сохраняем в соответствии с заданным хранилищем.
 * Каким образом мы будем просить мастер собирать новую метрику? Нужно ли его перезапускать? Что должно происходить при добавлении новой метрики с базой данных и другими хранилищами?
 * Три варианта:
    1) фабрика объектов (±);
    2) инверсия зависимостей;
    3) метаклассы.

 * * Для разных страниц (и разных машин!) — разные значения таймаутов и длительностей снятия скриншотов.
 * FakeSkreenshoter/FakeScreenshoter.
 * Утилита для простого исследования и анализа har-файлов, доставания из них простой информации (TTFB первого запроса/запроса к html; x-unique-id, проч.).
 * RPC-протокол для выполнения на клиентских машинах, например: https://grpc.io/docs/tutorials/basic/python.html
